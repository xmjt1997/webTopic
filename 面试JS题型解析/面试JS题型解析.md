# JS题型

### 1、ES6（set,map,symbol,proxy）



### 2、Promise

promise.all中三个promise请求，成功两个，失败一个，如何把成功的两个返回出来，链式调用



### 3、原型，原型链，继承

原型链的继承的那几个方式 还有优缺点，继承



### 4、闭包

阶乘

### 5、call，apply，bind，继承

手动实现bind



### 6、节流防抖函数



### 7、JS运行机制，Event Loop



### 8、JS基础数据类型转换

判断数据类型原理和方法



### 9、数组去重

遍历数组方法，数组常用api



### 10、深浅拷贝

JSON.Stringify缺点



### 11、unll和undefined的区别



### 12、排序算法（冒泡）



### 13、async，await，setTimeout用法区别



### 14、CommonJS和ES6模块化（ADM,CDM）



### 15、事件机制（捕获，目标，冒泡）



### 16、this指向



### 17、genterato函数



### 18、new的过程化



### 19、设计模式（单例模式，发布订阅）



### 20、JS垃圾回收机制（谷歌）

> ​	当程序执行一个函数，会创建一个函数执行上下文环境添加到栈的顶部，当函数被执行完成后，作用域被销毁，作用域内包含的变量也失去作业，这种销毁作用域，回首内存的过程就称为垃圾回收
>
> - **副垃圾回收器**：负责新生代区域的垃圾回收
>
> ​	1、通常我们创建的新对象都会优先分配到新生代的内存区域中，新生代内存拥有两个区域组成，每个区域都拥有2个状态，**工作状态**和**空闲状态**，两个区域的状态对立且互相转换。
>
> ​	2、在内存中新增的变量会分配到工作状态的那个区域，当程序运行一段时间后，**工作状态区域**内存即将到达存储上限，v8引擎会将**工作状态区域**中不再使用的对象进行标记。
>
> ​	3、系统将没有被标记的对象复制到**空闲状态区域**重新排列，将工作状态区域清空。
>
> ​	4、此时**工作状态区域**和**空闲状态区域**的**工作状态**进行调换
>
> ![](%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.png)
>
> ​	`晋升机制`：由于新生代区域的内存空间较小，满足晋升机制的对象将会放置到老生代区域进行存储。
>
> ​		`条件`：1、进过一次Scavenging算法，且未被标记清除的。
>
> ​				  2、再进行翻转置换的时候，被复制对象所占空间大于**工作状态区域**的**25%**
>
> ​	
>
> - **主垃圾回收器：**
>
>   主垃圾回收器主要用来回收老生代区域的垃圾
>
>   `	过程：`
>
>   1、标记：从一组的根元素开始，遍历递归这组跟元素，在这个遍历中能到达的对象称为活动对象，无法到达的元素可以判定为垃圾数据，进行**标记**。
>
>   2、清除：主垃圾回收器会直接将标记为垃圾的数据对象**直接清除**
>
> 





### 21、内存泄漏（浏览器卡顿原因查找）

> ​	**内存泄漏：**不再使用到的内存，没有及时释放，称为内存泄漏
>
> ​	**内存泄漏发生的原因：**
>
> 1. 缓存
> 2. 浏览器队列消费不及时
> 3. 定义全局变量
> 4. 计时器没有清楚
> 5. 闭包
> 6. 事件监听
>
> 
>
> ​	**避免内存泄漏方法：**
>
> 1. 少用全局变量，避免意外的全局变量定义（在函数中没有用var,let,const定义的变量就定义到全局上）
> 2. 合理使用闭包
> 3. 计时器要在合适的时机进行清除
>
> 
>
> ​	**谷歌浏览器内存泄漏查看方式：**
>
> - ​	**谷歌浏览器-->更多工具-->任务管理器  查看当前浏览器任务进程所占内存是否在合理范围内**
>   - 1、内存占用空间（Memory）该数值增大代表此时正在创建DOM节点
>   - 2、JavaScript使用的内存，实时数值代表当前页面上的对象正使用的内存，当页面稳定后，该值若持续增大，则有内存泄漏。
> - **使用chrome的时间轴记录可视化内存泄漏：**
>   - 谷歌调试工具-->Performance-->进行录制



### 22、JS堆栈

> ​	**基本数据类型：**
>
> ​		Number、String、Boolean、Null、Undefined、Symbol都是直接存放在栈内存中，每种类型的数据占用内存大小都是固定的，由系统自动分配释放。
>
> ​	**引用数据类型：**
>
> ​		Object、Array、Function等都是属于引用类型，这些数据存放在堆内存中，当需要访问这些数据的时候，系统通过栈内存的指针来获取引用地址关系找到该数据。



### 23、JS优化问题

> 1. **避免多次访问全局作用域**
>    - 在函数内部通过for循环多次访问全局变量是很消耗性能，可以在函数内定义一个变量来接收全局变量，通过访问函数内部的这个变量来进行优化
> 2. **避免使用with语句，**
>    - with语句执行时会创建自身的作用域，增加执行代码中作用域的长度 
> 3. **尽可能的用switch来替代if-else语句**
> 4. **使用位运算**
> 5. **避免声明多个变量**
>    - var a=1; var b=2; var c =3;  ` ==>`   var a=1, b=2, c=3
> 6. **避免使用 Array（）来创建数组，尽量用 let arr= [ ] 来字面量创建**
> 7. **避免使用 var obj=new Object( ) obj.a=1,obj.b=2 尽量使用 obj={a:1,b:2}**



### 24、Class的prototype和function的prototype区别



### 25、== 和===的区别转换

> ​	**变量1==变量2**
>
> ​	**双等号：==**
>
> 1. ​	首先比较两个变量的类型，若类型相同，则进行===的比较
>
> 2. 若类型不相同，进行转换后再次比较
>
>    **转换规则：**
>
>    ```
>    1. 数字 == 字符串 
>    
>     将字符串强制转化成数字，然后进行比较。返回true/false
>    
>    2. 字符串 == 对象
>    
>     将对象转化为字符串，然后在将字符串转化成数字，进行比较。 对象是先隐式调用toString(),然后再调用Number().
>    
>    3. null == undefined / undefined == null 
>    
>     都会返回 true
>    
>    4. 对象 == 对象
>    
>     比较的是在内存之中是不是同一个地址。
>    
>    5. 对象 == boolean值
>    
>     两边都先转化为数值，然后进行比较。
>    
>    6. 数字 == boolean值
>    
>     会将boolean转化为 数值，然后进行比较。
>    
>    ```
>
>    
>
> ​	**变量1===变量2**
>
> ​	**三等号：===**
>
> ​	直接进行类型比较，类型错误，直接返回` false`
>
> 



### 26、事件委托

> ​	**DOM中事件流的机制：**
>
> 1. ​	捕获
>
> 2. 目标阶段
>
> 3. 冒泡
>
>    事件的处理函数都是在冒泡阶段执行
>
>    ![](%E6%8D%95%E8%8E%B7%E5%86%92%E6%B3%A1.jpg)
>
> 
>
> ​	    **事件委托原理：**
>
> ​	利用DOM流事件冒泡的特性，申明一个父元素容器包裹需要添加监听事件的元素，在父容器上监听事件
>
> 用`event.target`来得到真实点击元素，触发定义事件。
>
> ​	**优点：**
>
> 1. ​	减少事件监听函数，节约内存
> 2. 优化了dom节点更新时相应事件的更新，元素增加删除不需要解除或添加事件
>
>    **缺点：**
>
> 1. 对于不冒泡的事件不支持
> 2. 层级太多的话，某曾阻止冒泡，导致委托失败
>
> ​    **建议：** `尽可能的就近委托`





### 27、ES7 | ES8

#### ES7新增方法：

> - ​	幂函数简洁方法=> Math.pow(2,2) `===`  2**2
>
> - 查找数组元素是否存在 
>
>   **odl：arr.indexOf( 查找内容 )**  => success：返回数组下标   err：-1  ==(查找NaN返回-1)==
>
>   **new：arr.includes( 查找内容 )** => success：返回true   err：返回false   ==(查找NaN返回true)==
>
>   `该函数第二个参数[ ],选择从哪个下标开始查找，负数为倒序查询，超出数组长度返回false 不查找`

#### ES8新增方法：

> ​	let obj ={
>
> ​	name:'lcz',
>
> ​	age:22
>
> ​	}
>
> ​	name:'lcz',
>
> ​	age:22
>
> ​	}
>
> ​		name:' lcz ',	
>
> ​	}
>
> - **Object.entries( obj )**  =>将对象中可枚举属性按二维数组方式返回
>
> - **Object.values( obj )**  => 按一位数组的方式只返回属性值
>
> - **字符串填充padStart()、padEnd()**
>
>   str.padStart(参数1，参数2 ) =>  参数1：填充后字符串的长度，参数2：要填充的内容 （长度小于当前字符串长度，则返回当前字符串）`往头部添加`
>
>   str.padEnd(参数1，参数2) =>  参数1：填充后字符串的长度，参数2：要填充的内容 （长度小于当前字符串长度，则返回当前字符串）`往尾部添加`



### 28、数组扁平化

> ​	**数组扁平化，就是将数组里面的数组打开，最后合并为一个数组**
>
> ​	let arr = [1,2,[3,4],5,[6],7,8]
>
> ​	1、递归函数
>
> ```js
>   function fn(arr) {
>             let arr1 = []
>             arr.forEach(item => {
>                 if (item instanceof Array) {
>                     arr1 = arr1.concat(fn(item))
>                 } else {
>                     arr1.push(item)
>                 }
>             })
>             return arr1
>         }
> 
>         let obj = fn(arr) // 1,2,3,4,5,6,7,8
>        
> ```
>
> ​	2、while循环判断+arr.some
>
> ```js
>  function fn(arr) {
>             while (arr.some(item => Array.isArray(item))) {
>                 arr = [].concat.apply([], arr)
>             }
>             return arr;
>         }
> 
>         let obj = fn(arr) //1,2,3,4,5,6,7,8
> ```
>
>   3、arr = [].concat.apply([], arr)



### 29、for in | forEach | for of 区别

> ​	**for in:**
>
> ​	for in (ES5语法，用来遍历key值) ：可以遍历对象的属性名和数组下标，数组下标为空时，会自	动跳过遍历 [1,2, ,3] => 0 1 3  `不推荐使用该方法遍历数组，下标丢失问题，建议遍历对象`
>
> ​	**for of:**
>
> ​	for of （ES6新增语法，用来遍历value）：可以直接遍历出对象键值对，数组的内容，字符串(空位子也能进行遍历)
>
> ​	**forEach：**
>
> ​	forEach：是一种数组的遍历方法(仅数组可用)，数组.foreach（(item,index,arr)=>{}），接受三个参数，第一个参数是遍历的当前元素，第二个参数是当前元素的数组下标，第三个参数是元素所属的数组对象。



### 30、script标签的async和defer

> ​	在正常的网页加载中，html会按照顺序来加载执行脚本，在脚本的加载执行中，会阻塞后续的dom渲染，影响用户体验。（不建议把script标签放置头部进行加载）
>
> ​	**defer属性：**让script脚本异步下载，但会把执行延迟到页面加载完成后，按拥有defer属性的script标签的顺序执行，即第二个延迟脚本在第一个延迟脚本执行后再执行
>
> ​	**async属性：**与defer属性相似，都在html页面结构加载完成后执行script脚本，但是async脚本不按照script的先后顺序执行，而是谁先加载完先执行，



### 31、进程和线程

> ​	**进程**：
>
> ​	进程是操作系统分配资源的最小单位，每个进程之间各自拥有独立的作用域空间
>
> ​	**浏览器中进程的作用：**
>
> - 负责页面的显示，功能交互，子进程管理
> - 渲染进程：将HTML,CSS,JS转换为可交互网页，每个Tab标签都有一个渲染进程
> - GPU进程：实现页面绘制和动画效果
> - 网络进程：负责网络资源的加载
> - 插件进程：每个浏览器插件对应一个插件进程
>
> 
>
> ​	**线程：**
>
> ​	线程是操作系统中程序执行的最小单位，一个进程下的所有线程贡献该进程的空间
>
> ​	**浏览器中线程作用：**
>
> - GUI渲染线程：负责HTML渲染，当需要重绘回流时候触发执行
> - JavaScript引擎线程：运行代码，v8引擎
> - 定时器线程：将定时器计数交给定时器线程来执行
> - 事件触发线程：将事件处理函数添加到队列的队尾，等待js引擎执行
> - 异步http请求线程：创建XMLHttpRequest请求开启新线程，放置队列队尾等待js引擎执行



### 32、XML和JSON区别

> ​	**XML:**
>
> ​	XML是一种用于标记电子文件使其具有结构性的`标记语言`
>
> ​	**JSON:**
>
> ​	JSON是一种轻量级的数据交换格式
>
> 
>
> ​	==共同点==：都是一种数据交换格式
>
> ​	==区别==：
>
> ​		1、xml是重量级的，json是轻量级的
>
> ​		2、xml传输占更多的带宽，json占用小，容易压缩
>
> ​		3、json用jackson，gson等方法解析，xml用dom，sax，demo4j等方法解析



